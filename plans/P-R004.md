# P-R004: Implementation Plan for R004

## Requirement Reference
[R004: Dynamic UI and Font Scaling with Resolution Changes](../requirements/R004.md)

## Objective
Implement a dynamic scaling system that adjusts all UI elements and fonts proportionally when users change the resolution setting, ensuring visual consistency across Desktop, High-DPI, and iPad Mini resolutions.

## Proposed Approach

### 1. Scaling Strategy
Create a centralized scaling system that:
- Uses Desktop (1920x1080) as the base resolution reference
- Calculates scale factors based on current resolution width
- Applies scale factors globally to all UI elements and fonts
- Updates scaling immediately when resolution changes

### 2. Technical Implementation

**Scale Factor Calculation:**
```
scale_factor = current_resolution_width / 1920.0

Desktop (1920x1080):   1.0
High-DPI (2560x1440):  1.333
iPad Mini (2048x1536): 1.067
```

**Global Scaling Approach:**
- Extend `GameSettings.gd` to manage UI scale factor
- Use Godot's `get_tree().root.content_scale_factor` for content scaling
- OR create custom theme with scaled font sizes
- OR use Control node scaling on root nodes

## Implementation Steps

### Task 1: Extend GameSettings with UI Scale Management
1. Add `ui_scale_factor` variable to GameSettings.gd
2. Add `calculate_scale_factor()` method based on current resolution
3. Add `apply_ui_scaling()` method to apply scale to root viewport
4. Update `apply_resolution()` to also call `apply_ui_scaling()`

**Files to modify:**
- `scripts/GameSettings.gd`

### Task 2: Implement Root Node Scaling (Option A - Recommended)
1. For each scene, scale the root Control node instead of individual elements
2. Apply scale to root nodes: MainMenu, GameScene, SettingsScene, WrongMatchPOC
3. Scale factor automatically cascades to all children

**Files to modify:**
- `scripts/MainMenu.gd`
- `scripts/GameBoard.gd`
- `scripts/SettingsScene.gd`
- `scripts/WrongMatchPOC.gd`

OR

### Task 2 Alternative: Create Dynamic Theme (Option B)
1. Create base theme resource with font sizes
2. Generate scaled theme at runtime based on resolution
3. Apply theme to all scenes via root node
4. Update theme when resolution changes

**Files to create/modify:**
- `resources/base_theme.tres` (optional)
- `scripts/ThemeManager.gd` (new singleton)
- Update `project.godot` autoload

### Task 3: Update Resolution Change Handler
1. In SettingsScene, ensure scale update happens after resolution change
2. Verify all scenes refresh their scaling
3. Test immediate visual updates without restart

**Files to modify:**
- `scripts/SettingsScene.gd`

### Task 4: Add Scaling to GameSettings Persistence
1. Save current scale factor to config file
2. Load and apply scale factor on startup
3. Ensure scale is applied before scenes are displayed

**Files to modify:**
- `scripts/GameSettings.gd`

### Task 5: Test and Refine Scaling
1. Test all three resolutions in each scene
2. Verify no UI clipping or overflow
3. Check font readability at all scales
4. Adjust base sizes if needed for better scaling results

## Files to be Modified/Created

**Modified:**
- `scripts/GameSettings.gd` - Add scale calculation and application
- `scripts/MainMenu.gd` - Apply root node scaling
- `scripts/GameBoard.gd` - Apply root node scaling  
- `scripts/SettingsScene.gd` - Apply root node scaling, update on resolution change
- `scripts/WrongMatchPOC.gd` - Apply root node scaling

**Optional (if using Theme approach):**
- `scripts/ThemeManager.gd` - New singleton for theme scaling
- `resources/base_theme.tres` - Base theme resource
- `project.godot` - Add ThemeManager autoload

## Technical Considerations

**Performance:**
- Root node scaling is efficient (single property change)
- Theme approach requires theme regeneration on resolution change
- Both approaches have minimal performance impact

**Compatibility:**
- Root node scaling works with existing UI structure
- No changes needed to individual UI elements
- Maintains current layout and design

**Maintainability:**
- Centralized scaling logic in GameSettings
- Easy to adjust scale factors for new resolutions
- Minimal code changes across scenes

## Recommended Approach
**Option A (Root Node Scaling)** is recommended because:
- Simple implementation
- No theme management overhead
- Direct control over scaling
- Easy to test and debug
- Automatic cascading to all children

## Implementation Sequence
1. Update GameSettings with scale calculation
2. Add root node scaling to each scene
3. Test each scene individually
4. Update resolution change handler
5. Add persistence
6. Final testing across all resolutions

## Risks and Mitigation

**Risk: UI element positions may shift unexpectedly**
- Mitigation: Use anchors and container nodes properly
- Test with extreme scale differences

**Risk: Some fonts may not scale smoothly**
- Mitigation: Use vector fonts (TTF/OTF)
- Test readability at all scale factors

**Risk: Custom-sized elements may break layout**
- Mitigation: Review all custom_minimum_size settings
- Use relative sizing where possible

## Estimated Effort
- GameSettings updates: 1 hour
- Scene scaling implementation: 2 hours
- Testing and refinement: 1-2 hours
- **Total: 4-5 hours**

---
**Status**: Implemented  
**Created**: 2024-12-24  
**Last Updated**: 2024-12-24  
**Approved By**: User
